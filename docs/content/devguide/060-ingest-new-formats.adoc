[[ingest-new-formats]]
=== New Formats

There are multiple ways to get data into GeoWave. In other sections we will discuss higher order frameworks, mapreduce
interfaces, etc. The intent here is "just the basics" - the least framework intensive way that one can load
geospatial data.

Information here will reference the SimpleIngest and SimpleIngestProducerConsumer examples in the geowave-examples project.

[NOTE]
====
The following example is using Accumulo for our datastore. Using HBase for the datastore would work the same way, except 
you would use the BasicHBaseOperations object instead of the BasicAccumuloOperations object.
====

==== Minimum information needed

Geowave requires a few pieces of fundamental information in order to persist data - these are:

* BasicAccumuloOperations object
* This class contains the information required to connect to an accumulo instance - and which table to use in accumulo.
** Zookeepers - in the format zookeeper1:port,zookeeper2:port,etc...
** Accumulo Instance ID - this is the "instance" that the Accumulo cluster you are connecting to was initialized with. It's a global
setting per cluster.
** Accumulo Username - this is the name of the user you would like to connect as. This is a user account managed by
accumulo, not a system, etc. user.
** Accumulo Password - this is the password associated with the user specified above. Again, this is an accumulo
controlled secret.
** Geowave Namespace - this is _not_ an Accumulo namespace; rather think of it as a prefix geowave will use on any
tables it creates. The only current constraint is only one index type is allowed per namespace.
* SimpleFeatureType instance
* http://www.opengeospatial.org/standards/sfs[Simple Feature Types] are an OGC specification for defining geospatial
features. Leveraging this standard is one of the easiest ways to get GIS data into GeoWave
* SimpleFeatureType instance - org.opengis.feature.simple.SimpleFeatureType - this defines the names, types, and other
metadata (nullable, etc) of a feature. Think of it as a Map of Name:Values where the values are typed.
* DataAdapter instance
* A geowave data adapter is an implementation of the DataAdapter interface that handles the persistence serialization of
whatever the object you are storing.
* We are storing SimpleFeatures, so can leverage the provided FeatureDataAdapter
* Index instance
* The final piece needed - the index defines which attributes are indexed, and how that index is constructed.
* There are lots of options for index configuration, but for convenience we have provided two defaults
* DataStore
* This is the piece that puts everything above together.
* Initialization required a BasicAccumuloOperations instance, the rest are provided as parameters for calls which need them.

==== Ingest some data

Here we will programmatically generate a grid of points at each location where a whole number latitude and longitude intersect.

==== Basic Accumulo Operations

[source, java]
----
/***
 * The class tells geowave about the accumulo instance it should connect to, as well as what tables it should create/store it's data in
 * @param zookeepers Zookeepers associated with the accumulo instance, comma separate
 * @param accumuloInstance  Accumulo instance name
 * @param accumuloUser   User geowave should connect to accumulo as
 * @param accumuloPass   Password for user to connect to accumulo
 * @param geowaveNamespace    Different than an accumulo namespace (unfortunate naming usage) - this is basically a prefix on the table names geowave uses.
 * @return  Object encapsulating the accumulo connection information
 * @throws AccumuloException
 * @throws AccumuloSecurityException
 */
protected BasicAccumuloOperations getAccumuloInstance(String zookeepers, String accumuloInstance, String accumuloUser, String accumuloPass, String geowaveNamespace)
  throws AccumuloException, AccumuloSecurityException {
    return new BasicAccumuloOperations(zookeepers, accumuloInstance, accumuloUser, accumuloPass, geowaveNamespace);
}
----

==== Simple Feature Type

A geometry field is required. Everything else is really optional. It's often convenient to add a text
latitude and longitude field for ease of display values (getFeatureInfo, etc.).

[source, java]
----
/***
 * A simple feature is just a mechanism for defining attributes (a feature is just a collection of attributes + some metadata)
 * We need to describe what our data looks like so the serializer (FeatureDataAdapter for this case) can know how to store it.
 * Features/Attributes are also a general convention of GIS systems in general.
 * @return Simple Feature definition for our demo point feature
 */
protected SimpleFeatureType createPointFeatureType(){

    final SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
    final AttributeTypeBuilder ab = new AttributeTypeBuilder();


    //Names should be unique (at least for a given GeoWave namespace) - think about names in the same sense as a full classname
    //The value you set here will also persist through discovery - so when people are looking at a dataset they will see the
    //type names associated with the data.
    builder.setName("Point");

    //The data is persisted in a sparse format, so if data is nullable it will not take up any space if no values are persisted.
    //Data which is included in the primary index (in this example lattitude/longtiude) cannot be null
    //Calling out latitude an longitude separately is not strictly needed, as the geometry contains that information.  But it's
    //convienent in many use cases to get a text representation without having to handle geometries.
    builder.add(ab.binding(Geometry.class).nillable(false).buildDescriptor("geometry"));
    builder.add(ab.binding(Date.class).nillable(true).buildDescriptor("TimeStamp"));
    builder.add(ab.binding(Double.class).nillable(false).buildDescriptor("Latitude"));
    builder.add(ab.binding(Double.class).nillable(false).buildDescriptor("Longitude"));
    builder.add(ab.binding(String.class).nillable(true).buildDescriptor("TrajectoryID"));
    builder.add(ab.binding(String.class).nillable(true).buildDescriptor("Comment"));

    return builder.buildFeatureType();
}
----

==== Spatial index

[source, java]
----
/***
 * We need an index model that tells us how to index the data - the index determines
 * -What fields are indexed
 * -The precision of the index
 * -The range of the index (min/max values)
 * -The range type (bounded/unbounded)
 * -The number of "levels"  (different precisions, needed when the values indexed has ranges on any dimension)
 * @return GeoWave index for a default SPATIAL index
 */
protected Index createSpatialIndex(){

    //Reasonable values for spatial and spatio-temporal are provided through static factory methods.
    //They are intended to be a reasonable starting place - though creating a custom index may provide better
    //performance is the distribution/characterization of the data is well known.
    return IndexType.SPATIAL.createDefaultIndex();
}
----

==== Data Adapter

[source, java]
----
/***
 * The dataadapter interface describes how to serialize a data type.
 * Here we are using an implementation that understands how to serialize
 * OGC SimpleFeature types.
 * @param sft  simple feature type you want to generate an adapter from
 * @return data adapter that handles serialization of the sft simple feature type
 */
protected FeatureDataAdapter createDataAdapter(SimpleFeatureType sft){
    return new FeatureDataAdapter(sft);
}
----

==== Generating and loading points

[source, java]
----
protected void generateGrid(
            final BasicAccumuloOperations bao ) {

        // create our datastore object
        final DataStore geowaveDataStore = getGeowaveDataStore(bao);

        // In order to store data we need to determine the type of data store
        final SimpleFeatureType point = createPointFeatureType();

        // This a factory class that builds simple feature objects based on the
        // type passed
        final SimpleFeatureBuilder pointBuilder = new SimpleFeatureBuilder(
                point);

        // This is an adapter, that is needed to describe how to persist the
        // data type passed
        final FeatureDataAdapter adapter = createDataAdapter(point);

        // This describes how to index the data
        final Index index = createSpatialIndex();

        // features require a featureID - this should be unqiue as it's a
        // foreign key on the feature
        // (i.e. sending in a new feature with the same feature id will
        // overwrite the existing feature)
        int featureId = 0;

        // get a handle on a GeoWave index writer which wraps the Accumulo
        // BatchWriter, make sure to close it (here we use a try with resources
        // block to close it automatically)
        try (IndexWriter indexWriter = geowaveDataStore.createIndexWriter(index)) {
            // build a grid of points across the globe at each whole
            // lattitude/longitude intersection
            for (int longitude = -180; longitude <= 180; longitude++) {
                for (int latitude = -90; latitude <= 90; latitude++) {
                    pointBuilder.set(
                            "geometry",
                            GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(
                                    longitude,
                                    latitude)));
                    pointBuilder.set(
                            "TimeStamp",
                            new Date());
                    pointBuilder.set(
                            "Latitude",
                            latitude);
                    pointBuilder.set(
                            "Longitude",
                            longitude);
                    // Note since trajectoryID and comment are marked as
                    // nillable we
                    // don't need to set them (they default ot null).

                    final SimpleFeature sft = pointBuilder.buildFeature(String.valueOf(featureId));
                    featureId++;
                    indexWriter.write(
                            adapter,
                            sft);
                }
            }
        }
        catch (final IOException e) {
            log.warn(
                    "Unable to close index writer",
                    e);
        }
    }
----

==== Other methods

There are other patterns that can be used. See the various classes in the geowave-examples project. The method displayed
above is the suggested pattern - it's demonstrated in SimpleIngestIndexWriter.java

The other methods displayed work, but are either more complicated than necessary (SimpleIngestProducerConsumer.java) or
not very efficient (SimpleIngest.java).
